## 找到无序数组中的最小k个数

### 【题目】
给定一个无序的长度为N的数组arr,找到其中最小的k个数

### 【要求】
如果先对数组进行排序再选取前k个值，时间复杂度和排序的时间复杂度相同，均为O(NlogN)。本题要求时间复杂度为O(Nlogk)和O(N)的方法。

### 【解答】
#### O(Nlogk)方法(堆排序)
维护一个大小为k的`大根堆`（或称：`最大堆`），存储目前选出的k个最小数，堆顶是最小的k个数里最大的；遍历数组，调整堆的元素，知道遍历结束。
#### O(N)方法(BFPRT)
理念：如果找到第k小的数，那么对于找出最小的k个数，只需要遍历一次数组，BFPRT算法就是在时间复杂度O(N)找到第k小的数。假设BFPRT算法的函数是`select(arr, k)`,该函数的作用是在arr中找到第k小的数，然后返回该数，具体过程如下：

1. 将arr中的n个元素划分成n/5组，每组5个元素，如果最后的组不够5个元素，那么最后剩下的元素作为一组（n%5个元素）；
2. 对每组进行插入排序，只针对每组内5个元素之间进行排序，组与组之间不进行排序。排序后找到每组中的中位数，如果组的元素个数为偶数，那么选择下中位数；
3. 步骤2中一共找到n/5个中位数，组成新的数组mArr，递归调用`select（mArr, mArr.length/2）`，意义是找到mArr的这个数组的中位数，即mArr中的第（mArr.length/2）小的数；
4. 步骤3最终返回一个数，假设为x，根据这个x划分整个数组（partition过程），在arr中比x小的数放在x的左边，比x大的数放在x的右边。假设划分完成后，x在arr中的位置下标位i；
5. 如果i==k，说明x为整个数组中的第k小的数，直接返回；如果i<k，说明x处在第k小的数的左边，应该在x的右边寻找第k小的数，所以递归调用select函数，在右半区寻找第k-i小的数；如果i>k，说明x处在第k小的数的右边，应该在x的左边寻找第k小的数，所以递归调用select函数，在左半区寻找第k小的数。

### 【代码】
[1.8minKDisorderArr.js](../codes/1.8minKDisorderArr.js)